<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/basscss.css" rel="stylesheet" type="text/css">
    <link href="css/codemirror.css" rel="stylesheet" type="text/css">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link href="css/monokai.css" rel="stylesheet" type="text/css">
    <link href="//cloud.webtype.com/css/fc0c09ce-40cc-4860-8ebe-67ff343dedda.css" rel="stylesheet" type="text/css" />
  </head>
  <body class="container">
    <header>
      <h1>Into the Land of Quil</h1>
      <h2>A Great and Valiant Journey of Derring-do</h2>
    </header>

    <div id="content">

      <div>
        <p><em>
          Good day, traveler. Today you embark upon a journey into Quil. May your
          sight be keen, for there are sights to behold.
        </em></p>
        <p>
          This is a tutorial
          for <a href="https://github.com/quil/quil">Quil</a>,
          a visual programming system that combines the powers
          of <a href="http://clojure.org/clojurescript">ClojureScript</a>
          and <a href="http://processingjs.org/">Processing.js</a>.
        </p>
        <p>
          Quil lets you do visual programming. You can even create drawings and
          animations that interact using the keyboard and the mouse.
        </p>
        <p>
          A Quil program is called a sketch. The <em>draw function</em> lies at
          the core of the sketch and does the work of actually drawing the
          visuals.
        </p>
        <p>
          You'll find many sketches in this tutorial. All of them are "live",
          change the code and you should immediately see the sketch change.
          Hover over a Quil function name to see what it does.
        </p>

        <h2>A Taste of Quil</h2>
        <p>
          These first few sketches will give you a taste of things to come. They
          are presented without much explanation. We'll dive into the details
          later. Play around with them, there's nothing you can break. Should you happen to make a mess, simply hit the red "revert" button, and you'll get the original code back.
        </p>

        <h3>The Pine Forest</h3>
        </p>
          The road to Quil starts in the Pine Forest. Try changing some numbers
          and see what happens!
        </p>

        <script type="cljs" class="editor" data-cmid="pine-forest">
;; This is the draw function which Quil will run
(defn draw-pine-forest []
  ;; First we set the stage: a background color, and no borders around shapes
  (background 20 200 151)
  (no-stroke)

  ;; Set a fill color for shapes. The numbers correspond with
  ;; red - green - blue, and go up to 255
  (fill 34 95 215)

  ;; Fill the width and height of the canvas with pine-forest
  (doseq [x (range 0 (width) 50)
          y (range 0 (height) 60)]
    (triangle (+ x 25) y
              x (+ y 50)
              (+ x 50) (+ y 50))
    (rect (+ x 16) (+ y 50) 16 10)))

(sketch
  :host "pine-forest"
  :size [300 300]
  :draw #'draw-pine-forest
  :setup #(frame-rate 1))
        </script>

        <p>
          That's already a lovely pattern we've got going. Knit it into a
          turtleneck and aunt Juliet will envy you forever. But there's more.
          How about we get things moving?
        </p>

        <h3>The Carousel</h3>
        <p>
          Time to make your head spin! This is an example of an animation. Think
          of it like an old fashioned film projector, spinning through a
          sequence of images. Quil calls your draw function many times in rapid
          succession to draw the individual images, called <em>frames</em>.
        </p>
        <p>
          Quil keeps a count of how many frames have passed. This sketch uses
          that <tt>frame-count</tt> to determine the position of the circle.
        </p>
        <script type="cljs" class="editor" data-cmid="carousel">
(defn draw-carousel []
  (background 255)
  (no-stroke)
  (fill 252 90 44)

  (let [radians (/ (frame-count) 20)
        x (+ 150 (* 100 (cos radians)))
        y (+ 150 (* 100 (sin radians)))
        width 30
        height 30]
      (ellipse x y, width height)))

(sketch
  :host "carousel"
  :size [300 300]
  :draw #'draw-carousel)
        </script>

        <h3>Paint Blotches</h3>

        <p>
          Quil also lets you interact with the keyboard and mouse. Move your mouse
          over the canvas to smear it with thick blotches of paint that run down
          the canvas.
        </p>

        <p>
          This is an example of a sketch that has <em>state</em>. This means
          that how it looks depends on its history, in this case, the past
          positions of the mouse.
        </p>

        <script type="cljs" class="editor" data-cmid="paint-blotch">
(def colors [[249 202 216]
             [232 181 188]
             [240 155 150]
             [209 188 219]
             [204 199 241]
             [198 221 245]
             [202 216 247]])

(defn- move-dots-down [state]
  (->> state
    (map #(update-in % [:pos 1] inc))
    (filter #(< (get-in % [:pos 1]) (height)))))

(defn paint-blotch-update
  "For each update cycle, register the new mouse position,
  then move all dots down"
  [state]
  (move-dots-down
    (let [x (mouse-x) y (mouse-y)]
      (if (and (> x 0) (> y 0) (< x (width)) (< y (height)))
        (conj state {:pos [x y] :color (rand-nth colors)})
        state))))

(defn paint-blotch-draw [state]
  (stroke-weight 25)
  (doseq [{[x1 y1] :pos color :color} state]
    (apply stroke color)
    (point x1 y1)))

(defn paint-blotch-setup []
  (background 255)
  (fill 0)
  (text "paint me!" 120 145)
  ;; The initial state is just an empty list
  (list))

(sketch
  :host "paint-blotch"
  :size [300 300]
  :setup #'paint-blotch-setup
  :update #'paint-blotch-update
  :draw #'paint-blotch-draw
  :middleware [quil.middleware/fun-mode])
                </script>

        <h2>Creating a sketch</h2>

        <p>
          To get Quil to draw something on the screen, you need a <tt>:draw</tt>
          function. You pass this function on to Quil when you call <tt>(sketch
          ,,,)</tt>. Quil accepts other functions as well, like
          a <tt>:setup</tt> function, which is called once when your sketch
          starts to run.
        </p>
        <p>
          The <tt>:host</tt> is the HTML <tt>id</tt> of the canvas element,
          which is where Quil will draw your sketch. In this tutorial, we have
          already set up a canvas for you, so no need to worry about that.
        </p>

        <h2>The Quil API</h2>

        <p>
          Inside the <tt>:draw</tt> function you have access to a long list of functions
          provided by Quil. Keep the <a href="http://quil.info/api/">Quil API
          reference</a> close to you at all times. Hang it above your bed, keep
          it under your pillow. It's a magical toolbox providing endless
          opportunities for your creations.
        </p>

        <h2>Drawing shapes</h2>

        <p>
          When you draw a shape, it stays on the canvas until you draw something
        on top of it. You can see this well in the last example, where the new
        "paint" is drawn on top of the old..
        </p>

        <p>
          With <tt>(background ...)</tt> you can get it a clean slate, since it
          will refill the whole canvas with a solid color. You can use it in
          your draw function to clear the canvas before drawing the new frame.
        </p>

<p>
  One of the easiest things you can draw is a rectangle. Quil's <tt>rect</tt>
  function takes four parameters, <tt>x</tt>, <tt>y</tt>, <tt>width</tt>
  and <tt>height</tt>. The first two arguments represent the location of the top
  left corner of rectangle on the canvas. Remember that in Quil, as in computer
  graphics in general, the origin <tt>(0, 0)</tt> of the coordinate system represents
  the top left corner of the drawing surface. In this example, we're drawing a
  centered equilateral rectangle or square.
</p>

<script type="cljs" class="editor" data-cmid="plain-rect">
(defn draw-rect []
  ;; Draw the rectangle
  (rect 50 50 200 200))

(sketch
  :host "plain-rect"
  :size [300 300]
  :draw #'draw-rect)
</script>

<p>
  By default Quil draws shapes with a light gray fill color, and a thin black
  border, on a dark gray background. Unless normcore becomes even more... norm,
  this color scheme won't win many prizes.
</p>

<p>
  To spice things up let's add some color! We already talked
  about <tt>background</tt>, which is really a lot like a draw function in its
  own right, since it refills the whole canvas. Shapes like rectangles or
  triangles on the other hand depend on a <em>fill</em> color, and
  a <em>stroke</em>, which has a color and
  a <em>stroke-weight</em>, the width of the stroke in pixels.
</p>

<p>
  By default all colors are specified
  in <a href="https://en.wikipedia.org/wiki/RGB_color_space">"rgb"</a>, meaning
  red - green - blue, with values between 0 and 255. the color space. Try and
  see how the colors change as you modify the three numbers!
</p>

<script type="cljs" class="editor" data-cmid="rect">
(defn draw-rect []
  ;; Fill the background with a solid color
  (background 20 200 151)

  ;; Set up drawing properties for the shapes that follow
  (stroke 214 240 248)
  (stroke-weight 1)
  (fill 34 95 215)

  ;; Draw the rectangle
  (rect 50 50 200 200))

(sketch
  :host "rect"
  :size [300 300]
  :draw #'draw-rect)
</script>

<p>
  Drawing a circle isn't any harder. While Quil does not come with a
  special function for drawing circles, it supplies a function for the general
  case of drawing ovals (or ellipses). That will work well — after all, a
  circle is just an ellipse with equal horizontal and vertical dimensions.
  The <tt>ellipse</tt> function takes the same arguments
  as <tt>rect</tt>: <tt>x</tt>, <tt>y</tt>, <tt>width</tt> and <tt>height</tt>.
  However, whereas in the case of <tt>rect</tt> the point <tt>(x,y)</tt>
  reprents the top-left corner of the figure, in <tt>ellipse</tt> it represents
  its center. This decision of Quil's authors makes sense: an ellipse doesn't
  have corners.
</p>

<script type="cljs" class="editor" data-cmid="circle">
(defn draw-circle []
  (background 20 200 151)
  (no-stroke) ;; use this if you don't want a border around your shapes
  (fill 34 95 215)

  (ellipse 150 150 200 200))

(sketch
  :host "circle"
  :size [300 300]
  :draw #'draw-circle
  :setup #(frame-rate 1))
</script>

        <h2>Animation and State</h2>

        <p>
          Drawing shapes is good, but making them move is better!
        </p>

        <p>
          This next sketch is an adaptation of a sketch by by Erik Svedäng.
        </p>

        <script type="cljs" class="editor" data-cmid="hyper">
(defn new-state []
  {:radius 0.0
   :color [(random 200 255) (random 0 150) (random 100 255)]})

(defn setup []
  (frame-rate 100)
  (background 255)
  (rect-mode :center)
  (new-state))

(defn tick [state]
  (update-in state [:radius] + 5.0))

(defn update-state [state]
  (if (< (:radius state) 300)
    (tick state)
    (new-state)))

(defn draw-state [state]
  (apply stroke (:color state))
  (let [hw (* 0.5 (width))
        hh (* 0.5 (height))]
    (dotimes [_ (quot (width) 10)]
      (let [rand-ang (random 0 q/TWO-PI)
            r (:radius state)]
        (line hh hw
              (+ hh (* (sin rand-ang) r))
              (+ hw (* (cos rand-ang) r)))))))

(sketch
  :host "hyper"
  :size [300 300]
  :setup #'setup
  :update #'update-state
  :draw #'draw-state
  :middleware [m/fun-mode])
         </script>


        <h2>Advanced Examples</h2>

        <p>
          These examples are taken from the Quil site. Can you find out how they work?
        </p>

        <h3>Tailspin by Erik Svedäng</h3>

        <script type="cljs" class="editor" data-cmid="tailspin">
(defn setup []
  (frame-rate 30)
  (let [max-r (/ (width) 2)
        n (int (map-range (width)
                            200 500
                            20 50))]
   {:dots (into [] (for [r (map #(* max-r %)
                                (range 0 1 (/ n)))]
                     [r 0]))}))

(def speed 0.0003)

(defn move [dot]
  (let [[r a] dot]
    [r (+ a (* r speed))]))

(defn update-state [state]
  (update-in state [:dots] #(map move %)))

(defn dot->coord [[r a]]
  [(+ (/ (width) 2) (* r (cos a)))
   (+ (/ (height) 2) (* r (sin a)))])

(defn draw-state [state]
  (background 255)
  (fill 0)
  (let [dots (:dots state)]
    (loop [curr (first dots)
           tail (rest dots)
           prev nil]
      (let [[x y] (dot->coord curr)]
        (ellipse x y 5 5)
        (when prev
          (let [[x2 y2] (dot->coord prev)]
            (line x y x2 y2))))
      (when (seq tail)
        (recur (first tail)
               (rest tail)
               curr)))
         </script>

        <h2>About Us</h2>

        <p>
          This interactive tutorial was create during a weekend by BERLIN!!
          (pronounced "Berlin Bang Bang")
          for <a href="http://clojurecup.com/">ClojureCup 2015</a>.
        </p>

        <p>
          We are Arne Brasseur, Chelsey Mitchell, Jelle Akkerman, and Paulus Esterhazy.
        </p>

        <p>
          All code is available under
          the <a href="http://www.eclipse.org/legal/epl-v10.html">Eclipe Public
          License</a> and can be
          found <a href="https://github.com/jellea/clojure-cup-2015">on
          Github</a>. Tutorial text and code samples
          are <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative
          Commons-Attribution-Share Alike 4.0</a>. The Quil examples taken from
          the Quil site are &copy; their respective authors, and are EPL like
          the Quil site.
        </p>

      </div>


    <div id="tooltip"></div>
    <script src="js/oneline.js" type="text/javascript"></script>
    <script src="js/compiled/clojure_cup_2015.js" type="text/javascript"></script>
  </body>
</html>
